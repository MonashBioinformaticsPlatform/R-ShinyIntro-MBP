# Reactivity{#reactivity}
In Section \@ref(structure), we mentioned that the Shiny server logic is based on reactive programming. The server takes input from the UI, runs the code chunks defined within, generates output and sends it to the UI. When you change the input, the server re-runs the code chunks and sends the updated output to the UI.

Consider the following example. The UI takes a single text input i.e. name of a person. The server concatenates the input string with "Hello" at the start and, "!" at the end and returns this string to the UI.
```{r, eval =F}
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
```
![](figs/Nitika.png){width=50%}
![](figs/bat.png){width=50%}
![](figs/Aladdin.png){width=50%}

### Challenge 3: Modify `greeting.R` to print the reverse{- .challenge}
Open `ShinyApps/reactive/greeting.R` and edit the file to print reverse of the input name. The new app should print the following:

* Hello Batman!

* The reverse of your name is: namtaB

## Reactive expressions save recomputation
Reactive expressions allow us to control which parts of the shiny app to re-compute and update, thus, prevents unnecessary computation. These expressions use the input value from a widget and return an output value and are updated automatically when the input widget changes.

Here are three ways of defining reactive expressions for the same computation. In these
```{r, echo = T, eval =F}
library(shiny)
y <- reactive(input$x + 1)

# or
y <- reactive({
    input$x + 1
})

# or
y <- reactive({
    return(input$x + 1)
})
```

Reactive expressions use cache memory i.e. saves its result the first time you run it. When loaded again, it returns the output value from the last computation.

Here's another example of reactivity explained using Pythagoras calculation. We have used `browser()` calls to understand the function. It creates a pause in the execution of the current expression inside a function and allows access to the R interpreter.
```{r, eval = F}
ui_pythagorus <- fluidPage(
    titlePanel("Hypotenuse app"),
    sliderInput("a", "Length a", 0, 10, 5),
    sliderInput("b", "Length b", 0, 10, 5),
    textOutput("result"))

server_pythagorus <- function(input, output, server) {
    a2 <- reactive({
        cat("Compute a squared.\n")

        input$a ** 2
    })
    browser() # browser 1

    b2 <- reactive({
        cat("Compute b squared.\n")

        input$b ** 2
    })
    browser() # browser 2

    output$result <- renderText({
        cat("Compute hypotenuse.\n")
        h <- sqrt(a2() + b2())
        cat("Done computing hypotenuse.\n")

        paste0("The hypotenuse is ", h)
    })
    browser() # browser 3
}
```

Now, we run the function
```{r, eval = F}
server_pythagorus()
```

## More complex examples of Shiny App:
