# Structure of a Shiny App{#structure}

A basic Shiny app consists of two objects:

* UI object - contains the code for the UI (user interface) elements i.e the visible part of the app; takes input and displays output.

* server object - contains the code for all the calculations the app will need. It contains the logical part of the code and access input from UI, performs the computation and generates an output which is returned to the UI.

<center><img src="https://github.com/MonashBioinformaticsPlatform/r-more/blob/gh-pages/figures/shiny_explanation.png?raw=true" width="409" height="240" /></center>

<p>&nbsp;</p>

The skeleton of every Shiny app looks like:
```{r, echo = T, eval = F}
library(shiny)

ui <- fluidPage(
  # front end interface
)

server <- function(input, output, session) {
  # back end logic
}

shinyApp(ui, server) # runs the app
```

## UI 

This is the front-end of the shiny app that allows you to capture (input) and display (output) a variety of data types. Fundamentally the UI is an HTML document with shiny functions returning chunks of HTML code. Fortunately, we don't have to write the HTML code directly ourselves, Shiny has R functions that do that instead.

The UI object controls the layout and appearance of the app. The UI makes use of widgets to interact with data. In this section, we'll look at examples of shinyWidgets that insert input controls.

The first example is a slider. Open the `app_slider.R` inside `ShinyApps` folder to understand how the slider widget works.

```{r widget1, echo = T, eval = F}
library(shiny)
sliderInput("slider1", "Decimal",
            min = -1, max = 1,
            value = 0.8, step = 0.2)
```

![](figs/slider.png){width=50%}

```{r, echo= T, eval = F}
renderPrint({paste("The number selected by the slider is:", input$slider1)})
```

![](figs/slider_out.png){width=60%}


```{r}
library(shiny)
fluidPage(
    
  # Copy the chunk below to make a group of checkboxes
  checkboxGroupInput("checkGroup", label = h3("Checkbox group"), 
    choices = list("Choice 1" = 1, "Choice 2" = 2, "Choice 3" = 3),
    selected = 2),
  
  
  hr(),
  fluidRow(column(3, verbatimTextOutput("value")))
  
)


```

The [shiny gallery](https://shiny.rstudio.com/gallery/#demos) has a section for application layouts. This is a useful of resource for ideas on how to structure the appearance of your app.

To see what widgets are available, look at the [Shiny widget gallery.](http://shiny.rstudio.com/gallery/widget-gallery.html) or consult the [Shiny cheatsheet](http://shiny.rstudio.com/images/shiny-cheatsheet.pdf).

## Layout

The complexity of your application may have an impact on the complexity of your layout. For instance, an application that contains only one or two widgets and one or two outputs may only need one page to fit all these elements. If however there are lot of controls and results to display it might be easier to organize these under tabs or a navbar.

A layout with three panels: a title panel, a sidebar panel and a main panel.
```{r,eval=FALSE}
ui <- fluidPage( # fluidPage - this function creates a display that auto adjusts to the browser window
  # further elements set to define the appearance will be placed within fluidPage
  titlePanel("this is a title panel"),
  
  sidebarLayout( # this function creates a layout with two pane21ls, one panel takes about a third of the screen width, the other panel takes about two thirds of the screen width.
    # the position of the sidebar can be moved by providing the `position = "right" argument to the sidebarLayout function
    sidebarPanel("this is the sidebar panel"),
    mainPanel("this is the main panel")
  )
)
```

Building a UI involves nesting a lot of components inside each other. From this example here we can see that `sidebarPanel` and `mainPanel` are nested within `sidebarLayout`. `sidebarLayout` itself is also nested within `fluidPage`. As more components are added to the app, e.g widgets and outputs, they too will be nested within the panel functions to control their location on the layout.

The above layout is probably the most common layout used with shiny apps. It's good for an app with only a few number of components. You may want to add navbar and tab sets if you have a large number of components.


```{r}
ui <- fluidPage( 
  titlePanel("this is a title panel"),
  
  sidebarLayout( 
    sidebarPanel("this is the sidebar panel"),
    mainPanel( 
      tabsetPanel( # this function takes an argument of `position = "left"` (arguments can be "left", "right", "below". default is above)
        # this argument directs where the tabs are positioned
        tabPanel("plot results"),
        tabPanel("table results"),
        tabPanel("fun gifs")
      )
    )
  )
)
```

For more information about the application layout (including nav bars and lists), we recommend this [resource](https://shiny.rstudio.com/articles/layout-guide.html). For more information about tab sets specifically, we recommend this [article](https://shiny.rstudio.com/articles/tabsets.html).

Another thing to note that a lot of the functions that build the UI are essentially wrapping HTML code within R functions. This means that the UI can also be customized by directly writing HTML code or by using [wrapper tag functions](https://shiny.rstudio.com/articles/tag-glossary.html). This is beyond the scope of this course but we thought it was worth mentioning.

### Activity 2: Does the `tabsetPanel` need to be nested in the `sidebarLayout`? {- .activity}


## Widgets

There is a wide variety of available pre-built widgets but all of them share a common basic framework. All widget input functions have the same first argument i.e. `inputID`. This is an identifier that connects the UI with the server. If for example `inputID = select`, you can access the input in the server as `input$select`. We'll discuss more about the server in the next section.


* The `inputID` is like a variable in R and must follow the naming convention. It must be a string that may contain only letters, numbers, and underscores.

* Like a variable, the `inputID` has to be unique so it can be accessed inside the server.

Here are some more examples of Shiny widgets:
```{r, echo = F}
shinyUI(navbarPage("Navbar",
                   tabPanel("Widgets!",
                            selectInput("select", label = h3("Select box"), 
                                        choices = list("Choice 1" = 1, "Choice 2" = 2, "Choice 3" = 3), 
                                        selected = 1),
                            renderPrint({input$select}),
                            textInput("text", label = h3("Text input"), value = "Enter text..."),
                            renderPrint({input$text})
                   ),
                   tabPanel("More widgets!",
                            checkboxGroupInput("checkGroup", label = h3("Checkbox group"), 
                                               choices = list("Circle" = "circle", "Square" = "square", "Triangle" = "triangle"),
                                               selected = "circle"),
                            
                            renderPrint({ input$checkGroup })
                   )
)
)

```
The `choices` augment takes a list. This list can either be unnamed or named. In the case of a named list, such as the one above for the `checkboxGroupInput` widget, the names will be displayed on the UI (e.g "Choice 1") while the value (e.g 1) will be passed to the server side to be use1d for further computations. For an unnamed list, the value will both be displayed on the UI and passed to the server side.

### Activity 3: Now, open the `widgets.R` inside `ShinyApps` folder, and try running it.{- .activity}
There are a variety of widgets available in Shiny Apps. Have a go at them!!

Please Note: For now, keep the `Server Logic` and `Run the App` as it is. We'll explain these in next sections.

## Server

The server object contains the code for building the app. It contains the code for data processing, analysis and plotting. It takes input from the UI, runs (and re-runs) code chunks defined within, generates output and sends it to the UI.

The server logic follows reactive programming, which defines a graph of dependencies. The idea is that when the input changes, all related outputs are updated. This makes the Shiny App interactive. 

In the Shiny skeleton code, server is defined as a function with three arguments- input, output and session. These arguments are created by Shiny when the session starts and cannot be changed.
```{r, eval = F}
library(shiny)

ui <- fluidPage(
  # front end interface
)

server <- function(input, output, session) {
  # back end logic
}

shinyApp(ui, server)
```

### Input
This is a list-like object that contains all input data from the UI. The input data can be accessed as `input$inputId`, where `inputId` is defined in the UI for any given widget. For example, if we refer back to the check-box example in shiny widgets, we specified the `inputId` as `checkGroup`. We can access the value of that specific input using `input$checkGroup`. It will contain the value `1` as we specified this in the `selected` argument. This value will be updated everytime a user selects a different check-box.


```{r, eval = F}
ui <-  fluidPage(
  # Copy the chunk below to make a group of checkboxes
  checkboxGroupInput(inputId = "checkGroup",
                     label = h3("Checkbox group"),
                     choices = list("Choice 1" = 1,
                                    "Choice 2" = 2,
                                    "Choice 3" = 3),
                     selected = 1)
)
```

### Output
This is also a list-like object named according to the `outputId` arguments created in the UI. In the following example, the `outputId` for the `textOutput` is defined as `greeting` inside the UI. Inside the server function, the output is stored in the `outputId` using `output$greeting` (think of it as a storing a value inside a variable). Alternatively, think of it as a way to direct the results of a computation on the server side to a specific `outputID`. 

The value of the `greeting` is `Hello, World!` 

```{r, eval = F}
ui <- fluidPage(
  textOutput(outputId =  "greeting") # defines outputID
)

server <- function(input, output, session) {
  output$greeting <- renderText("Hello, World!") # stores output in the outputID
}
```

The `render` function sets up a special "reactive context" that automatically tracks the input values the output has used. It also converts the output of your R code into HTML to be display on a web page.

### Challenge 2: Rewrite your `ui` to create a Shiny app that contains following:{- .challenge}

1. Title that says "Challenge 2"

2. Select `airquality` from the default datasets in R (Hint: Refer to `app_ui.R`).

3. Create three widgets:

   * `helpText()` to write "List of variables to choose from".
   
   * `selectInput()` to list variables in the `airquality` dataset. 
   
   * `sliderInput()` to add a slider where, `min = 0`; `max = 30` and selected values are: `(5,21)`
   
4. Try replacing the list options in selectInput by `colnames(airquality)`.

Your Shiny app should look like this:

![](figs/challenge1.png)
<p>&nbsp;</p>
> Hint: Use the Shiny skeleton code to create a new R-script and edit the UI part:

```{r, eval = F}
library(shiny)

ui <- fluidPage(
  # edit this part
)

server <- function(input, output, session) {
  
}

shinyApp(ui, server)
```

