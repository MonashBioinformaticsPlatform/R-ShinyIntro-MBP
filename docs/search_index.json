[["index.html", "Introduction to R Shiny Chapter 1 Prerequisites 1.1 Download files 1.2 Overview Source code Authors and copyright", " Introduction to R Shiny Nitika K., Adele B., Paul F. H. 2022-03-31 Chapter 1 Prerequisites Before the tutorial please install R and RStudio, Download R Download RStudio Then install packages from CRAN and Bioconductor with the following R code: install.packages(&quot;shiny&quot;) install.packages(&quot;DT&quot;) source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(c( &quot;BSgenome.Scerevisiae.UCSC.sacCer3&quot;, &quot;TxDb.Scerevisiae.UCSC.sacCer3.sgdGene&quot;, &quot;GenomicRanges&quot;, &quot;rtracklayer&quot;, &quot;Gviz&quot;)) Make sure you are running R 3.3 and Bioconductor 3.3, or higher. # To upgrade an old Bioconductor installation source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;BiocUpgrade&quot;) 1.1 Download files tutorial.R Download these files. tutorial.R contains all the code in the “tutorial” link below. During the tutorial, we will be stepping through tutorial.R in RStudio. 1.2 Overview Introduction to Shiny Structure of a Shiny app Shiny tutorial Reactivity Source code This book was created in R using the rmarkdown and bookdown packages! GitHub page Authors and copyright This course is developed for the Monash Bioinformatics Platform by Nitika Kandhari, Adele Barugahare and Paul Harrison. This work is licensed under a CC BY-4: Creative Commons Attribution 4.0 International License. The attribution is “Monash Bioinformatics Platform” if copying or modifying these notes. "],["intro.html", "Chapter 2 Introduction 2.1 What is Shiny 2.2 Another R package - What’s so special about Shiny? 2.3 Example apps 2.4 Create your first Shiny App", " Chapter 2 Introduction 2.1 What is Shiny Shiny is an R package that makes it easy to build interactive web applications. It provides an easy way to present R data analysis interactively and over the web. It is magical in the sense that it allows you to create complicated apps without any prior knowledge of HTML, CSS or JavaScript straight from your R code. Shiny essential wraps your R code and transforms it into a dynamic web app. The powerful features of the shiny programming are the User Interface (UI) and the reactivity which will be discussed in later sections. To use it, simply open up R Studio and: #install.packages(&quot;shiny&quot;) library(shiny) 2.2 Another R package - What’s so special about Shiny? It’s easier than learning HTML, CSS and JavaScript, although you can use those to build your own custom Shiny elements You don’t need to port any of your R code into another language in order to build a web app Incredible flexibility, you can generate dynamic UI elements and create interactive plots It adds reproducibilty to your graphs You don’t need to generate a billion plots manually. It can easily be added to a markdown document - like this one! 2.3 Example apps Here are some apps made by Monash bioinformaticians: Stuart’s TCP app that went into his Nature paper: Stuart K. Archer, Nikolay E. Shirokikh, Traude H. Beilharz, &amp; Thomas Preiss. (2016). Dynamics of ribosome scanning and recycling revealed by translation complex profiling. Nature, 2016. Paul’s Varistran app Varistran github page 2.4 Create your first Shiny App Activity 1: Creating a ShinyApp that prints “Hello, World!” Create a new .R file, paste the following code inside, save it as app.R. library(shiny) #1. calls the library `shiny` ui &lt;- fluidPage( #2. defines user interface, an HTML webpage &quot;Hello, world!&quot; # prints Hello, world! on webpage ) server &lt;- function(input, output, session) { #3. specifies app behavior } app_hello &lt;- shinyApp(ui, server) # 4. starts Shiny application Click on Run App in the top right corner (see fig below). Or you can also use the keyboard shortcut: Cmd/Ctrl + Shift + Enter. 2.4.1 Breakdown of the code This is a trivial Shiny app that performs 4 tasks: Calls the shiny package. Defines user interface (ui) which in this case is an HTML webpage, for us to interact with. In this user interface, it prints “Hello, world!”. Creates a function called server that specifies app behavior. Currently, the function body is empty. It means this function (and the app) doesn’t do anything except for printing “Hello, world!” We will later add more controls to this function to control app behavior. Construct a Shiny application from UI and server and stores it in a variable called app_hello. 12 &gt; In the R console, there is some text displayed in red which indicates the URL of your app. Your app can be found at 127.0.0.1, indicates “this computer” and 5537 is a randomly assigned port number. 2.4.2 Running a Shiny App Aside from the Run App button and the shortcut, there are many other ways to run a shiny app: runApp(app_hello) runGadget(app_hello) runGadget(app_hello, viewer=dialogViewer(&quot;App 1&quot;)) print(app_hello) app_hello Activity 2: Now, open the app_ui.R inside ShinyApps folder and examine what it does. First run the app as it is. Then uncomment the lines and run again and observer the changes. Can you explain the function of this app? "],["structure.html", "Chapter 3 Structure of a Shiny App 3.1 UI 3.2 Layout 3.3 Widgets 3.4 Server", " Chapter 3 Structure of a Shiny App A basic Shiny app consists of two objects: UI object - contains the code for the UI (user interface) elements i.e the visible part of the app; takes input and displays output. server object - contains the code for all the calculations the app will need. It contains the logical part of the code and access input from UI, performs the computation and generates an output which is returned to the UI.   The skeleton of every Shiny app looks like: library(shiny) ui &lt;- fluidPage( # front end interface ) server &lt;- function(input, output, session) { # back end logic } shinyApp(ui, server) # runs the app 3.1 UI This is the front-end of the shiny app that allows you to capture (input) and display (output) a variety of data types. Fundamentally the UI is an HTML document with shiny functions returning chunks of HTML code. Fortunately, we don’t have to write the HTML code directly ourselves, Shiny has R functions that do that instead. The UI object controls the layout and appearance of the app. The UI makes use of widgets to interact with data. Here, we’ll look at examples of shinyWidgets that insert input controls. library(shiny) sliderInput(&quot;slider1&quot;, label = h4(&quot;This code will make a slider \\n&quot;), min = 0, max = 100, value = 50) This code will make a slider renderPrint({paste(&quot;The number selected by the slider is:&quot;, input$slider1)}) fluidPage( # Copy the chunk below to make a group of checkboxes checkboxGroupInput(&quot;checkGroup&quot;, label = h3(&quot;Checkbox group&quot;), choices = list(&quot;Choice 1&quot; = 1, &quot;Choice 2&quot; = 2, &quot;Choice 3&quot; = 3), selected = 1), hr(), fluidRow(column(3, verbatimTextOutput(&quot;value&quot;))) ) Checkbox group Choice 1 Choice 2 Choice 3 The shiny gallery has a section for application layouts. This is a useful of resource for ideas on how to structure the appearance of your app. To see what widgets are available, look at the Shiny widget gallery. or consult the Shiny cheatsheet. 3.2 Layout The complexity of your application may have an impact on the complexity of your layout. For instance, an application that contains only one or two widgets and one or two outputs may only need one page to fit all these elements. If however there are lot of controls and results to display it might be easier to organize these under tabs or a navbar. A layout with three panels: a title panel, a sidebar panel and a main panel. ui &lt;- fluidPage( # fluidPage - this function creates a display that auto adjusts to the browser window # further elements set to define the appearance will be placed within fluidPage titlePanel(&quot;this is a title panel&quot;), sidebarLayout( # this function creates a layout with two pane21ls, one panel takes about a third of the screen width, the other panel takes about two thirds of the screen width. # the position of the sidebar can be moved by providing the `position = &quot;right&quot; argument to the sidebarLayout function sidebarPanel(&quot;this is the sidebar panel&quot;), mainPanel(&quot;this is the main panel&quot;) ) ) Building a UI involves nesting a lot of components inside each other. From this example here we can see that sidebarPanel and mainPanel are nested within sidebarLayout. sidebarLayout itself is also nested within fluidPage. As more components are added to the app, e.g widgets and outputs, they too will be nested within the panel functions to control their location on the layout. The above layout is probably the most common layout used with shiny apps. It’s good for an app with only a few number of components. You may want to add navbar and tab sets if you have a large number of components. ui &lt;- fluidPage( titlePanel(&quot;this is a title panel&quot;), sidebarLayout( sidebarPanel(&quot;this is the sidebar panel&quot;), mainPanel( tabsetPanel( # this function takes an argument of `position = &quot;left&quot;` (arguments can be &quot;left&quot;, &quot;right&quot;, &quot;below&quot;. default is above) # this argument directs where the tabs are positioned tabPanel(&quot;plot results&quot;), tabPanel(&quot;table results&quot;), tabPanel(&quot;fun gifs&quot;) ) ) ) ) For more information about the application layout (including nav bars and lists), we recommend this resource. For more information about tab sets specifically, we recommend this article. Another thing to note that a lot of the functions that build the UI are essentially wrapping HTML code within R functions. This means that the UI can also be customized by directly writing HTML code or by using wrapper tag functions. This is beyond the scope of this course but we thought it was worth mentioning. 3.2.1 Challenge 0 {- .activity}. Does the tabsetPanel need to be nested in the sidebarLayout? 3.3 Widgets There is a wide variety of available pre-built widgets but all of them share a common basic framework. All widget input functions have the same first argument i.e. inputID. This is an identifier that connects the UI with the server. If for example inputID = select, you can access the input in the server as input$select. We’ll discuss more about the server in the next section. The inputID is like a variable in R and must follow the naming convention. It must be a string that may contain only letters, numbers, and underscores. Like a variable, the inputID has to be unique so it can be accessed inside the server. Here are some more examples of Shiny widgets: Navbar Widgets! More widgets! Select box Choice 1 Choice 2 Choice 3 Text input Checkbox group Circle Square Triangle The choices augment takes a list. This list can either be unnamed or named. In the case of a named list, such as the one above for the checkboxGroupInput widget, the names will be displayed on the UI (e.g “Choice 1”) while the value (e.g 1) will be passed to the server side to be use1d for further computations. For an unnamed list, the value will both be displayed on the UI and passed to the server side. Activity 3: Now, open the widgets.R inside ShinyApps folder, and try running it. There are a variety of widgets available in Shiny Apps. Have a go at them!! Please Note: For now, keep the Server Logic and Run the App as it is. We’ll explain these in next sections. 3.4 Server The server object contains the code for building the app. It contains the code for data processing, analysis and plotting. It takes input from the UI, runs (and re-runs) code chunks defined within, generates output and sends it to the UI. The server logic follows reactive programming, which defines a graph of dependencies. The idea is that when the input changes, all related outputs are updated. This makes the Shiny App interactive. In the Shiny skeleton code, server is defined as a function with three arguments- input, output and session. These arguments are created by Shiny when the session starts and cannot be changed. library(shiny) ui &lt;- fluidPage( # front end interface ) server &lt;- function(input, output, session) { # back end logic } shinyApp(ui, server) 3.4.1 Input This is a list-like object that contains all input data from the UI. The input data can be accessed as input$inputId, where inputId is defined in the UI for any given widget. For example, if we refer back to the check-box example in shiny widgets, we specified the inputId as checkGroup. We can access the value of that specific input using input$checkGroup. It will contain the value 1 as we specified this in the selected argument. This value will be updated everytime a user selects a different check-box. ui &lt;- fluidPage( # Copy the chunk below to make a group of checkboxes checkboxGroupInput(inputId = &quot;checkGroup&quot;, label = h3(&quot;Checkbox group&quot;), choices = list(&quot;Choice 1&quot; = 1, &quot;Choice 2&quot; = 2, &quot;Choice 3&quot; = 3), selected = 1) ) 3.4.2 Output This is also a list-like object named according to the outputId arguments created in the UI. In the following example, the outputId for the textOutput is defined as greeting inside the UI. Inside the server function, the output is stored in the outputId using output$greeting (think of it as a storing a value inside a variable). Alternatively, think of it as a way to direct the results of a computation on the server side to a specific outputID. The value of the greeting is Hello, World! ui &lt;- fluidPage( textOutput(outputId = &quot;greeting&quot;) # defines outputID ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText(&quot;Hello, World!&quot;) # stores output in the outputID } The render function sets up a special “reactive context” that automatically tracks the input values the output has used. It also converts the output of your R code into HTML to be display on a web page. Challenge 1: Rewrite your ui to create a Shiny app that contains following: Title that says “Challenge 1” Select airquality from the default datasets in R (Hint: Refer to app_ui.R). Create three widgets: helpText() to write “List of variables to choose from”. selectInput() to list variables in the airquality dataset. sliderInput() to add a slider where, min = 0; max = 30 and selected values are: (5,21) Try replacing the list options in selectInput by colnames(airquality). Your Shiny app should look like this:   Hint: Use the Shiny skeleton code to create a new R-script and edit the UI part: library(shiny) ui &lt;- fluidPage( # edit this part ) server &lt;- function(input, output, session) { } shinyApp(ui, server) 3.4.3 Session Typically, we don’t alter the session object as its default behavior is adequate for most needs. The session object is an environment that can be used to access information and functionality relating to the session. For more information, check the documentation here "],["reactivity.html", "Chapter 4 Reactivity 4.1 Overview of Reactivity 4.2 Reactive expressions save recomputation", " Chapter 4 Reactivity 4.1 Overview of Reactivity In Section 3, we mentioned that the Shiny server logic is based on reactive programming. The server takes input from the UI, runs the code chunks defined within, generates output and sends it to the UI. When you change the input, the server re-runs the code chunks and sends the updated output to the UI. Consider the following example. The UI takes a single text input i.e. name of a person. The server concatenates the input string with “Hello” at the start and, “!” at the end and returns this string to the UI. ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name, &quot;!&quot;) }) } Challenge 3: Modify greeting.R to print the reverse Open ShinyApps/reactive/greeting.R and edit the file to print reverse of the input name. The new app should print the following: Hello Batman! The reverse of your name is: namtaB 4.2 Reactive expressions save recomputation Example of a reactive expression library(shiny) y &lt;- reactive(input$x + 1) # or y &lt;- reactive({ input$x + 1 }) # or y &lt;- reactive({ return(input$x + 1) }) Reactivity explained using Pythagoras calculation: We have used browser() calls to debug the function ui_pythagorus &lt;- fluidPage( titlePanel(&quot;Hypotenuse app&quot;), sliderInput(&quot;a&quot;, &quot;Length a&quot;, 0, 10, 5), sliderInput(&quot;b&quot;, &quot;Length b&quot;, 0, 10, 5), textOutput(&quot;result&quot;)) server_pythagorus &lt;- function(input, output, server) { a2 &lt;- reactive({ cat(&quot;Compute a squared.\\n&quot;) input$a ** 2 }) browser() b2 &lt;- reactive({ cat(&quot;Compute b squared.\\n&quot;) input$b ** 2 }) browser() output$result &lt;- renderText({ cat(&quot;Compute hypotenuse.\\n&quot;) h &lt;- sqrt(a2() + b2()) cat(&quot;Done computing hypotenuse.\\n&quot;) paste0(&quot;The hypotenuse is &quot;, h) }) browser() } Now, we run the function server_pythagorus() There are two types of functions that we can use to access reactivity. We can use render functions or the reactive function. In most simple examples of Shiny applications, we are able to directly connect/link an input widget and an output object with a renderX function (e.g renderTable, renderText, renderPlot). These renderX functions are activated/re-calculated whenever the value of input$someInputId provided to that renderX function is updated/changed. In such situations, the result is directed to an output on the UI. But what if you wanted to use the calculated result for multiple outputs? Since the render function directs its result into an output, this means that this value is not freely available to be used by other render functions. One solution could be to run the calculation multiple times with each render function. This isn’t a very efficient solution but it might be one that would do the job. However consider if the calculation was a very large one, rerunning this calculation multiple times might slow the app down a lot to the point of it becoming inoperable. This is a situation where a reactive function would be useful. The output of a reactive function can be assigned to a variable name and this variable can be called within different render functions. Like a render function, the reactive function is recalculated any time the value of input$anInputId inside the reactive function is updated or changed. Therefore for a more efficient solution, the calculation could performed in the reactive function once and then in multiple render functions, the value of the reactive function could be called. Here is an example without a reactive function, somewhat contrived: library(shiny) data(&quot;airquality&quot;) ui &lt;- fluidPage( sliderInput(inputId = &quot;tempModifier&quot;, label = &quot;this slider will multiply the temperature column of the `airquality` dataset by the selected value&quot;, min = 0, max = 100, value = 50), textOutput(outputId = &quot;airResult&quot;), plotOutput(outputId = &quot;plotResult&quot;) ) server &lt;- function(input, output, session) { output$airResult &lt;- renderText({ new_temp &lt;- airquality$Temp * input$tempModifier paste0(&quot;the average of the modified temperature is:&quot;, mean(new_temp)) }) output$plotResult &lt;- renderPlot({ new_temp &lt;- airquality$Temp * input$tempModifier # we are performing the same calculation twice plot(x=airquality$Temp, y = new_temp, ylim = c(0, 8000)) }) } shinyApp(ui, server) Shiny applications not supported in static R Markdown documents Here an example with a reactive function: library(shiny) data(&quot;airquality&quot;) ui &lt;- fluidPage( sliderInput(inputId = &quot;tempModifier&quot;, label = &quot;this slider will multiply the temperature column of the `airquality` dataset by the selected value&quot;, min = 0, max = 100, value = 50), textOutput(outputId = &quot;airResult&quot;), plotOutput(outputId = &quot;plotResult&quot;) ) server &lt;- function(input, output, session) { # we&#39;ve used a reactive function to create a reactive variable which can be used by both render functions new_temp &lt;- reactive({ airquality$Temp * input$tempModifier }) output$airResult &lt;- renderText({ paste0(&quot;the average of the modified temperature is:&quot;, mean(new_temp())) }) output$plotResult &lt;- renderPlot({ plot(x=airquality$Temp, y = new_temp(), ylim = c(0, 8000)) }) } shinyApp(ui, server) Shiny applications not supported in static R Markdown documents "],["tutorial.html", "Chapter 5 Shiny tutorial 5.1 Setting up a shiny app 5.2 Building the UI layout 5.3 Data processing on the server side", " Chapter 5 Shiny tutorial We’ll build a Shiny App that takes a csv file containing data for 6 samples and the raw counts for 1000 genes. Each sample is a column and each gene is a row. One sample will be plotted on the x-axis and another sample on the y-axis. We’ll also want to be able to display a table of the selected columns but that will be for the challenge. ## sample1 sample2 sample3 sample4 sample5 sample6 ## gene_1 89 4664 274 126 1267 143 ## gene_2 568 3456 201 9 139 504 ## gene_3 275 4307 449 187 7909 188 ## gene_4 3913 5912 4082 4318 8892 3851 ## gene_5 3382 155 2897 2626 2069 3456 ## gene_6 4167 5194 4404 4757 4765 4156 ## gene_7 4831 227 5009 4554 479 4713 ## gene_8 2532 3395 3000 3441 4575 2460 ## gene_9 3274 1658 3074 3189 2293 3277 ## gene_10 3272 4169 3454 3192 7403 3344 Top ten rows of the raw data used to build the shiny app 5.1 Setting up a shiny app Create one blank R script (Click File &gt; New File &gt; R Script). Save it inside the demo folder with the name app.R. Now we’re going to create a blank app. In app.R, type: library(shiny) ui &lt;- fluidPage( ) server &lt;- function(input, output) { } shinyApp(ui = ui, server = server) 5.2 Building the UI layout The ui object controls the appearance of the app. There are a number of layouts and widgets that an app can have. For this tutorial, we will use a title panel with a sidebar layout underneath. This is a common layout for Shiny apps. The sidebar layout will give the app two panels, a sidebar and a main panel. To look up more layouts, check the Shiny gallery. Update the ui object to: ui &lt;- fluidPage( titlePanel(&quot;My first app&quot;), sidebarLayout( sidebarPanel(&quot;This is a sidebar panel&quot;), mainPanel(&quot;And this is the main panel&quot;) ) ) Then run app. You should be able to make out the layout of the app now. The top of the window is where the title panel is located and beneath it are two panels, laid out with the sidebar to the left and the larger main panel to the right. 5.2.0.1 Using widgets We are going to add two widgets to the ui. These will control which samples gets plotted to the x and y axis of the plot and will be located in the sidebar panel. We will use selectInput to create these widgets but these could easily be swapped out for other widgets such radiobuttons. To see what widgets are available, look at the Shiny widget gallery or consult the Shiny cheatsheet. To start off with, let’s add just one widget to the sidebar. ui &lt;- fluidPage( titlePanel(&quot;My first app&quot;), sidebarLayout( sidebarPanel(&quot;This is a sidebar panel&quot;, selectInput(inputId = &quot;x_select&quot;, label = &quot;Select x-axis&quot;, choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;) ), mainPanel(&quot;And this is the main panel&quot;) ) ) This is where Shiny starts to get a little tricky, a lot of ui code will be end up being nested in more code. So far, we have the selectInput widget nested inside sidebarPanel nested inside siderbarLayout which is nested in fluidPage. So we’ve stuck a function inside a function inside a function inside a function. Phew, that’s a lot to keep track of! Many common problems that’ll prevent a shiny app from running simply come from just putting a comma or a bracket in the wrong place. We cannot emphasis this point enough - keeping track of opening and closing brackets and your commas is a good skill to cultivate when building Shiny apps! One quick way to check on your brackets is to move the cursor next to a bracket - in RStudio - that will highlight the other bracket paired with if (if one exists, that is!). Fig 1. The cursor is placed next the opening bracket for mainPanel and the closing bracket is highlighted. Fig 2. Here, though the cursor is in the same place but the original closing bracket to mainPanel is missing. The next closing bracket is used by mainPanel instead, which now means sidebarLayout does not have a closing bracket. The app would not work in this situation. Moving back to our ui, let’s break down the selectInput function. inputId is the name of widget, in this case x_select is the name that’ll be used in the server object to access the current value of the widget. The labels argument takes a string that will be used to label above the widget. choices takes a list of values and can be a bit confusing to understand. For simplicity’s sake, we have given an unnamed list, which will directly display the values themselves. \"sample1\" happens to be a column name in the data the app will be using, so this widget can be used to select which column gets plotted. However, if the names of the choices needs to be different from the values, a named list can be used. For example: choices = list(&quot;Sample 1&quot; = &quot;sample1&quot;, &quot;Sample 2&quot; = &quot;sample2&quot;, &quot;Sample 3&quot; = &quot;sample3&quot;, &quot;Sample 4&quot; = &quot;sample4&quot;, &quot;Sample 5&quot; = &quot;sample5&quot;, &quot;Sample 6&quot; = &quot;sample6&quot;) In \"Sample 1\" = \"sample1\" the string \"Sample 1\" is the text that will appear in the widget, whereas \"sample1\" is the value that will be returned from the widget. Using this would make a much neater looking widget. Think of the name as purely cosmetic and what you’ll see while the value is what’s important and will be used behind the scenes for calculations. You could change the names to whatever you wanted without having on effect the app. Finally, selected chooses which value the widget will start on when the app is run. Now to add the second widget. To show the difference between an unnamed and a named list, the second widget will use a named list for choices. ui &lt;- fluidPage( titlePanel(&quot;My first app&quot;), sidebarLayout( sidebarPanel(&quot;This is a sidebar panel&quot;, selectInput(inputId = &quot;x_select&quot;, label = &quot;Select x-axis&quot;, choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;), selectInput(inputId = &quot;y_select&quot;, label = &quot;Select y-axis&quot;, choices = list(&quot;Sample 1&quot; = &quot;sample1&quot;, &quot;Sample 2&quot; = &quot;sample2&quot;, &quot;Sample 3&quot; = &quot;sample3&quot;, &quot;Sample 4&quot; = &quot;sample4&quot;, &quot;Sample 5&quot; = &quot;sample5&quot;, &quot;Sample 6&quot; = &quot;sample6&quot;), selected = &quot;sample2&quot;) ), mainPanel(&quot;And this is the main panel&quot;) ) ) This widget is nearly identical to the first, all that has changed is the name of the widget, the use of a named list and which sample has been pre-selected. This widget has been called y_select and it will start on the value sample2 so that the columns selected for the x and y axis will be different. 5.2.0.2 Adding some outputs There’s one last thing to do before moving onto the server object. The app has inputs now, but it doesn’t have any outputs! For this app, we will use three outputs. Two are going to be purely diagnostic so we can check that our selectInputs are working. They will not be included in our final app. The one output that will remain in our final app is plotOutput, as we want to generate a plot and it will be located in the main panel. There are numerous types of outputs Shiny can generate - to find out what other outputs Shiny is capable of, consult the Shiny cheatsheet or the Shiny website. ui &lt;- fluidPage( titlePanel(&quot;My first app&quot;), sidebarLayout( sidebarPanel(&quot;This is a sidebar panel&quot;, selectInput(inputId = &quot;x_select&quot;, label = &quot;Select x-axis&quot;, choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;), selectInput(inputId = &quot;y_select&quot;, label = &quot;Select y-axis&quot;, choices = list(&quot;Sample 1&quot; = &quot;sample1&quot;, &quot;Sample 2&quot; = &quot;sample2&quot;, &quot;Sample 3&quot; = &quot;sample3&quot;, &quot;Sample 4&quot; = &quot;sample4&quot;, &quot;Sample 5&quot; = &quot;sample5&quot;, &quot;Sample 6&quot; = &quot;sample6&quot;), selected = &quot;sample2&quot;) ), mainPanel(&quot;And this is the main panel&quot;, textOutput(outputId = &quot;check_x_select&quot;), textOutput(outputId = &quot;check_y_select&quot;), plotOutput(outputId = &quot;my_plot&quot;) ) ) ) my_plot is the ID of the plotoutput and it tells the server object file where to direct data. Same goes for the two textOutputs. Run the app and see what you’ll get. Does it look any different? At the moment, the app will display nothing because we haven’t told it do any calculations and generate a plot or display text. To do that, we need to move on to the server side. 5.3 Data processing on the server side The app now has a full UI but nothing is happening on the backend. To make the app interactive, that’s where the server object comes into play. Think of it as the object that contains an R analysis. The structure of this object can vary immensely depending on the complexity of the app itself. First, we need to check on our two selectInput widgets, see if they are working correctly, before we move on to plotting. When building a Shiny app, it’s useful to have create outputs to check to see if parts of the app are doing what they should be, for both the ui and the server code. This step can be omitted, but we’ll go through it to demonstrate what the selectInputs are doing. server &lt;- function(input, output) { output$check_x_select &lt;- renderText({ print(input$x_select) }) output$check_y_select &lt;- renderText({ print(input$y_select) }) } Now run the app. There are a number of render functions in Shiny, renderTable, renderText, renderPrint, etc, depending on what type of data needs to be output. If you want to check what render options exist, got the Shiny website reference page. Whenever a render function is called, it needs to be directed to an output that exists in the ui object. In the case of output$check_x_select, we have pointed the renderText function to check_x_select, which was the id of a textOutput in the UI. This means that the result of renderText is sent to the check_x_select output. Inside the renderText function, we print the value of the x_select. To access a value of a input widget, we use input$input_Id. Once the app is running, every time the value of the input changes, a render function that depends on it will be re-run. So if we changed the value of the x_select, only the first renderText statement is re-calculated but the second one, which doesn’t depend on x_select will not be re-calculated. Notice that despite the difference between the two selectInputs (one uses a named list and the other doesn’t), that the values returned are the same. Once again, using a named list changes the appearance of the ui but not the actual values of the widgets. Now that we’ve seen that our widgets are working correctly, we can remove the diagnostic lines of code from both the ui and server. You can either comment them out or delete them. Your app should currently look like this: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;My first app&quot;), sidebarLayout( sidebarPanel(&quot;This is a sidebar panel&quot;, selectInput(inputId = &quot;x_select&quot;, label = &quot;Select x-axis&quot;, choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;), selectInput(inputId = &quot;y_select&quot;, label = &quot;Select y-axis&quot;, choices = list(&quot;Sample 1&quot; = &quot;sample1&quot;, &quot;Sample 2&quot; = &quot;sample2&quot;, &quot;Sample 3&quot; = &quot;sample3&quot;, &quot;Sample 4&quot; = &quot;sample4&quot;, &quot;Sample 5&quot; = &quot;sample5&quot;, &quot;Sample 6&quot; = &quot;sample6&quot;), selected = &quot;sample2&quot;) ), mainPanel(&quot;And this is the main panel&quot;, plotOutput(outputId = &quot;my_plot&quot;) ) ) ) server &lt;- function(input, output) { } shinyApp(ui = ui, server = server) The final app will be rather simple. It will take one render functions and send the output to the UI. To get going, let’s create an empty renderPlot. server &lt;- function(input, output) { output$my_plot &lt;- renderPlot({ }) } Now let’s give the render function some data to display, the first two columns from the csv shiny_sample_data.csv. server &lt;- function(input, output) { output$my_plot &lt;- renderPlot({ #Read in the sample csv dat &lt;- read.csv(&quot;data-files/shiny_sample_data.csv&quot;, row.names = 1) #Pull out the first and second columns in dat x_axis &lt;- dat[, &quot;sample1&quot;] y_axis &lt;- dat[, &quot;sample2&quot;] #Create a basic dot plot plot(x = x_axis, y_axis) }) } The complete working code looks like: titlePanel(&quot;My first app&quot;) #Changed up the input and output IDs so that they don&#39;t conflict with the earlier app. sidebarLayout( sidebarPanel(&quot;App input control panel&quot;, selectInput(&quot;x_select1&quot;, label = h3(&quot;Select x-axis&quot;), choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;), selectInput(inputId = &quot;y_select1&quot;, label = &quot;Select y-axis&quot;, choices = list(&quot;Sample 1&quot; = &quot;sample1&quot;, &quot;Sample 2&quot; = &quot;sample2&quot;, &quot;Sample 3&quot; = &quot;sample3&quot;, &quot;Sample 4&quot; = &quot;sample4&quot;, &quot;Sample 5&quot; = &quot;sample5&quot;, &quot;Sample 6&quot; = &quot;sample6&quot;), selected = &quot;sample2&quot;) ), mainPanel(&quot;App output panel&quot;, plotOutput(&quot;plot1&quot;, width = 600, height = 600) ) ) output$plot1 &lt;- renderPlot({ dat &lt;- read.csv(&quot;data-files/shiny_sample_data.csv&quot;, row.names = 1) #Pull out the first and second columns in dat x_axis &lt;- dat[, &quot;sample1&quot;] y_axis &lt;- dat[, &quot;sample2&quot;] plot(x = x_axis, y = y_axis) }) The app has a plot now…but it isn’t interactive, if we change the widget values, it has no effect on what is plotted on the figure. That’s because the first two columns were selected directly in the renderPlot function. However, we could change to call the widget values instead using input. server &lt;- function(input, output) { output$my_plot &lt;- renderPlot({ #Read in the sample csv dat &lt;- read.csv(&quot;data-files/shiny_sample_data.csv&quot;, row.names = 1) #Pull out a column for the x and y axis each x_axis &lt;- dat[, input$x_select] y_axis &lt;- dat[, input$y_select] #Create a basic dot plot plot(x = x_axis, y_axis) }) } The complete working app code looks like: library(shiny) library(utils) ui &lt;- fluidPage( titlePanel(&quot;My first app&quot;), sidebarLayout( sidebarPanel(&quot;This is a sidebar panel&quot;, selectInput(inputId = &quot;x_select&quot;, label = &quot;Select x-axis&quot;, choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;), selectInput(inputId = &quot;y_select&quot;, label = &quot;Select y-axis&quot;, choices = list(&quot;Sample 1&quot; = &quot;sample1&quot;, &quot;Sample 2&quot; = &quot;sample2&quot;, &quot;Sample 3&quot; = &quot;sample3&quot;, &quot;Sample 4&quot; = &quot;sample4&quot;, &quot;Sample 5&quot; = &quot;sample5&quot;, &quot;Sample 6&quot; = &quot;sample6&quot;), selected = &quot;sample2&quot;) ), mainPanel(&quot;And this is the main panel&quot;, textOutput(outputId = &quot;check_x_select&quot;), textOutput(outputId = &quot;check_y_select&quot;), plotOutput(outputId = &quot;my_plot&quot;, width = 600, height = 600) ) ) ) server &lt;- function(input, output) { output$check_x_select &lt;- renderText({ print(input$x_select) }) output$check_y_select &lt;- renderText({ print(input$y_select) }) output$my_plot &lt;- renderPlot({ #Read in the sample csv dat &lt;- read.csv(&quot;data-files/shiny_sample_data.csv&quot;, row.names = 1) #Pull out a column for the x and y axis each x_axis &lt;- dat[, input$x_select] y_axis &lt;- dat[, input$y_select] #Create a basic dot plot plot(x = x_axis, y_axis) }) } shinyApp(ui = ui, server = server) Congratulations! You’ve made your first app! Activity 4: Modily x- and y-axes labels Can you figure out how to change the axis titles to the name of the selected sample. One of selectInput widgets also need to be changed to a named list. Other than that, you’re good to go. Hint: plot(x = blah, y = plah, xlab = “Label for the x-axis”, ylab = “Label for the y-axis”) Now imagine you had an experiment where you had many conditions and you needed to plot each one against each other. Instead of plotting each one individually, with a Shiny app, you could easily visualise the different conditions without having to write code for each one of them and then download them. If you want to get a shareable link of your app, so that other people can access it over the web: http://biotraining.erc.monash.edu:3838/your_username/demo/. Make sure to change the url to have your biotraining account name in place of your_username. Challenge 2: Modify the app to add the following library(ggplot2) # 1. Add ui titlePanel(&quot;My slightly more complicated app&quot;) sidebarLayout( sidebarPanel(&quot;App input control panel&quot;, selectInput(&quot;x_select3&quot;, label = h3(&quot;Select x-axis&quot;), choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample1&quot;), selectInput(&quot;y_select3&quot;, label = h3(&quot;Select y-axis&quot;), choices = list(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;, &quot;sample5&quot;, &quot;sample6&quot;), selected = &quot;sample2&quot;) # 2. Add sliderInput ), mainPanel(&quot;App output panel&quot;, plotOutput(&quot;plot3&quot;, width = 600, height = 600) # 3. Add tableOutput ) ) # 4. Add server logic output$plot3 &lt;- renderPlot({ dat &lt;- read.csv(&quot;data-files/shiny_sample_data.csv&quot;, row.names = 1) x_axis &lt;- dat[, input$x_select3] y_axis &lt;- dat[, input$y_select3] plot(x = x_axis, y = y_axis) }) # 5. Redirect output to a variable to be called in mainPanel The first step is to sort out the ui. We want to print the number of rows in the data as decided by a slider. Create a slider input widget. Hint: The code for a slider looks something like this: sliderInput(“inputIDyouwant”, label = “Slider”, min = , max = , value = 50) To find out more about how a slider works check the Shiny widget gallery Create a new output called a tableOutput to print the data in tabular format. Hint: The code for it looks like: tableOutput(outputId = “table1”) Define the server object. You’ll need to direct the result of a renderTable function to the new output. For an ever further challenge, create a reactive function and pass the reactive variable to the two render functions. Read the csv file only once in the application Hint: The table that is displayed is a subset of the full csv. It shows only the two currently selected columns. Remember that a dataframe can be subsetted to show only certain columns using x[, c(column_a, column_c, column_z)] Inside the renderTable call, you’ll need a function that shows you the top of a table. The head function is ideal for this. If you aren’t familiar with how head works, check the help manual for head with ?head to see the arguements it takes. An important thing to note is that only one thing is returned from inside a render function (usually the last line inside that function). Therefore a variable, such as dat created inside the renderPlot will not exist outside that renderPlot function. You’ll need to read the csv of data back in again in the renderTable function. "],["resources.html", "Chapter 6 Further Reading", " Chapter 6 Further Reading Mastering Shiny by Hadley Wickham Shiny tutorials by R-Studio Shiny widgets gallery Shiny written tutorials Shiny dashboards "]]
